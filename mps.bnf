
Document  : meta 'Document' '(' heading_star Group_opt ')'
          |                     heading_star Group_opt 

# ISSUE: allow heading before every Group, not just before the root group?

# none of these show up in the XML, except as hints for base & prefix
# and except for import

heading   : meta base
          | meta prefix
          | meta import
          | meta include
          | meta alias
          | meta local

include   : 'Include' '(' iri ')'

import    : 'Import' '(' iri ')'
	  | 'Import' '(' iri TERM ')'

base      : 'Base' '(' iri ')'

iri       : ANGLEBRACKIRI
          | BARE_IRI

# these are declarations which introduce a new word (along with forall and exists)

prefix    : 'Prefix' '(' bare_word iri ')'

alias     : 'Alias' '(' bare_word iri ')'

local     : 'Local' '(' bare_word_star ')'

new_var   : bare_word

old_var   : VARNAME

# "bare_word" is a special token requiring a different state for the
# lexer -- it matches words, even keywords, and just returns the text
# of the word.  

# The logic here is designed to allow new keywords to be added to the
# language later without breaking existing documents.  Specifically,
# we read a bare_word, then add it to the proper token list (vars,
# aliases, prefixes, etc) and the lexer will recognize it as that
# instead of as a keyword.  You can't use the new keyword in such a
# document without renaming the item, but at least the semantics
# didn't change under you.

# For details on this kind of lexer trick, see PLY documentation
# example with new_scope, push_scope()/pop_scope() (or nearly any C
# parser)

bare_word  : begin_accept_bare_word BARE_WORD end_accept_bare_word

begin_accept_bare_word : EMPTY

end_accept_bare_word : EMPTY

# what about:  declare word (PREFIX|ALIAS|LOCAL|EXIVAR|UNIVAR)

# ruleset?
Group     : meta 'Group' '(' Group_star ')'
          | formula

#        : meta '(' formula ')'
formula : meta 'External' '(' uniterm ')'
	       | meta 'External' '(' frame ')'
	       | meta 'Forall' new_var_plus '(' formula ')'
	       | meta 'Exists' new_var_plus '(' formula ')'
	       | formula 'And' formula
	       | formula 'Or' formula
	       | formula  ':-' formula
	       | uniterm
	       | frame
	       | TERM '=' TERM
               | TERM '<' TERM
               | TERM '#' TERM
	       | TERM '##' TERM

uniterm        : TERM '(' arg_list ')'
               | TERM '(' Name_arrow_TERM_plus ')'


frame          : TERM '[' frame_arg_list ']'

#TERM_arrow_TERM : TERM '->' TERM

frame_arg_list : '->'

arg_list : ','
#arg_list  : EMPTY
#          | TERM
#          | arg_list ',' TERM

TERM           : '(' TERM ')'
	       | meta Const 
	       | meta old_var
	       | meta uniterm
	       | meta 'External' '(' uniterm ')'
	       | meta TERM '+' TERM
	       | meta TERM '-' TERM

Const          : STRING_HAT_HAT iri
	       | CONSTSHORT

CONSTSHORT     : STRING
	       | INTEGER
	       | DECIMAL
	       | LOCAL
	       | iri


meta           : '(*' '*)'
	       | '(*' iri '*)'
	       | '(*' iri formula '*)'
	       | '(*' formula '*)'
#	       | EMPTY

# require meta for now, while debugging...


# NAME_ARROW is a ...
#
#   oh, we don't need this, just make arrow be an infix operator which makes
#   a "tagged expression", which is suitable for use as an argument...   yes?
#
Name_arrow_TERM : NAME_ARROW TERM

