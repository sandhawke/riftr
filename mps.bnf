
Document  : heading_star meta 'Document' '(' heading_star Group_opt ')'
          | heading_star                                  Group_opt

# ISSUE: allow heading before every Group, not just before the root group?

# none of these show up in the XML, except as hints for base & prefix
# and except for import

heading   : meta base
          | meta prefix
          | meta import
          | meta include
          | meta alias
          | meta local

include   : 'Include' '(' iri ')'

import    : 'Import' '(' iri ')'
          | 'Import' '(' iri expr ')'

base      : 'Base' '(' iri ')'

iri       : ANGLEBRACKIRI
          | BARE_IRI

# these are declarations which introduce a new word (along with forall and exists)

prefix    : 'Prefix' '(' bare_word iri ')'

alias     : 'Alias' '(' bare_word iri ')'

local     : 'Local' '(' bare_word_star ')'

new_var   : bare_word

old_var   : VARNAME

# "bare_word" is a special token requiring a different state for the
# lexer -- it matches words, even keywords, and just returns the text
# of the word.  

# The logic here is designed to allow new keywords to be added to the
# language later without breaking existing documents.  Specifically,
# we read a bare_word, then add it to the proper token list (vars,
# aliases, prefixes, etc) and the lexer will recognize it as that
# instead of as a keyword.  You can't use the new keyword in such a
# document without renaming the item, but at least the semantics
# didn't change under you.

# For details on this kind of lexer trick, see PLY documentation
# example with new_scope, push_scope()/pop_scope() (or nearly any C
# parser)

bare_word  : begin_accept_bare_word BARE_WORD end_accept_bare_word

begin_accept_bare_word : EMPTY

end_accept_bare_word : EMPTY

# what about:  declare word (PREFIX|ALIAS|LOCAL|EXIVAR|UNIVAR)

# ruleset?
#  can't just put expr expr expr in group --  f (3) ... etc
Group     : meta 'Group' '(' Group ')'   
          | expr

expr          : meta '(' expr ')'
              | meta 'External' '(' frame ')'
              | meta 'External' '(' atomic ')'
              | meta 'Forall' new_var_plus '(' expr ')'
              | meta 'Exists' new_var_plus '(' expr ')'
              | meta Const 
              | meta old_var
              | expr 'And' expr
              | expr 'Or' expr
              | expr  ':-' expr
              | expr '=' expr
              | expr '<' expr
              | expr '#' expr
              | expr '##' expr
              | expr '+' expr
              | expr '-' expr
              | atomic
              | frame


atomic        : expr '(' arg_list ')'
              | expr '(' Name_arrow_expr_plus ')'


frame         : expr '[' frame_arg_list ']'

frame_arg_list : EMPTY
               | frame_args

frame_args     : expr '->' expr
	       | frame_args ',' expr '->' expr

arg_list  : EMPTY
          | args

args      : expr
          | arg_list ',' expr   
# without the comma, we get some meta conf.


Const          : STRING_HAT_HAT iri
               | CONSTSHORT

CONSTSHORT     : STRING
               | INTEGER
               | DECIMAL
               | LOCAL
               | iri


# first expr is IRI
# if there's only one, look to see if it's an IRI or formula
meta           : '(*' '*)'
               | '(*' expr '*)'
	       | '(*' expr ',' expr '*)'
               | EMPTY 


# require meta for now, while debugging...


# NAME_ARROW is a ...
#
#   oh, we don't need this, just make arrow be an infix operator which makes
#   a "tagged expression", which is suitable for use as an argument...   yes?
#
Name_arrow_expr : NAME_ARROW expr

